\documentclass[
	% -- opções da classe memoir --
%	article,			% indica que é um artigo acadêmico
	11pt,				% tamanho da fonte
	openright,
	twoside,			% Oposto a oneside
	a4paper,			% tamanho do papel. 
	english,			% idioma adicional para hifenização
	french,
	brazil,				% o último idioma é o principal do documento
	sumario=tradicional
	]{abntex2}

\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{nomencl} 			% Lista de simbolos
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% para melhorias de justificação
% Tabelas longas -> + de uma página
\usepackage{longtable}

\usepackage[brazilian,hyperpageref]{backref}	% Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}					% Citações padrão ABNT

\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
\renewcommand{\backref}{}
\renewcommand*{\backrefalt}[4]{
	\ifcase #1 %
		Nenhuma citação no texto.%
	\or
		Citado na página #2.%
	\else
		Citado #1 vezes nas páginas #2.%
	\fi}%
% ---

\titulo{Conceitos básicos de Orientação Objeto}
\autor{Paulino Ng\thanks{paulino.ng@gmail.com}
}
\local{Brasil}
\data{2018, v-0.3.1}

% informações do PDF
\makeatletter
%\hypersetup{
%     	%pagebackref=true,
%		pdftitle={\@title}, 
%		pdfauthor={\@author},
%    		pdfsubject={Conceitos básicos de OO},
%	    	pdfcreator={PDFLaTeX with abnTeX2},
%		pdfkeywords={OO}{Scott Ambler}{UML}{Java EE}, 
%		colorlinks=true,       		% false: boxed links; true: colored links
%    		linkcolor=blue,         % color of internal links
%    		citecolor=blue,        	% color of links to bibliography
%    		filecolor=magenta,      % color of file links
%		urlcolor=blue,
%		bookmarksdepth=4
%}
\makeatother
% --- 

\makeindex

% Altera as margens padrões
% ---
\setlrmarginsandblock{2cm}{2cm}{*}
\setulmarginsandblock{2cm}{2cm}{*}
\checkandfixthelayout

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.0cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% Espaçamento simples
\SingleSpacing

\begin{document}
\selectlanguage{brazil}

% Retira espaço extra obsoleto entre as frases.
\frenchspacing 

%\maketitle

\imprimircapa

\pdfbookmark[0]{\contentsname}{lof}
\listoffigures*
\cleardoublepage*

\pdfbookmark[0]{\contentsname}{lot}
\listoftables*
\cleardoublepage*

\pdfbookmark[0]{\contentsname}{toc}
\tableofcontents*
\cleardoublepage*

% resumo em português
%\begin{resumoumacoluna}
%Este texto objetiva introduzir alguns dos principais conceitos da tecnologia Orientada a Objetos, OO.
%O texto é fortemente baseado no capítulo 2 do livro \cite{Ambler:TOP:3ed}, com acréscimos baseados em \cite{uml:j2ee} e outros textos.
%
%\vspace{\onelineskip}
%\noindent
% \textbf{Palavras-chave}: OO. UML. JEE.
%\end{resumoumacoluna}

\textual

% try to generate a table of contents after summary
%\tableofcontents

%\section{Introdução}
%\addcontentsline{toc}{section}{Introdução}
\chapter{Conceitos Básicos de Orientação a Objetos}

\input{cboo.tex}

\chapter{Padrões de Projeto}

Neste capítulo veremos um resumo das ideias apresentadas em \cite{DP:explained} e \cite{design:patterns} sobre padrões de projetos. Shalloway e Trott acreditam que é possível aprender orientação objeto simultaneamente com os padrões de projeto. E é o que tentamos fazer neste texto. Não veremos os padrões com a minúcia desses livros, apenas vamos apresentar alguns dos aspectos mais essenciais. Os leitores mais interessados em padrões de projeto devem ler pelo menos estes dois textos.

Um padrão tem quatro elementos essenciais:
\begin{enumerate}
\item O \emph{nome do padrão} permite distinguir rapidamente o padrão de outros e ter uma noção da aplicação e o que é o padrão. Encontrar bons nomes pode ser difícil, mas provavelmente podemos aplicar também a regra da coesão aqui: Se não há uma boa maneira de nomeá-lo, há uma boa chance do padrão não está correto. Óbvio existem exceções para esta regra e, às vezes, precisamos criar um nome novo (uma palavra nova) para representar o conceito.

\item O \emph{problema} descreve quando aplicar o padrão. Ele explica o problema e seu contexto (as forças relevantes).

\item A \emph{solução} descreve os elementos que compõe o projeto, seus relacionamentos, responsabilidades e colaborações. A solução não descreve um projeto concreto específico, ou uma implementação.

\item As \emph{consequências} descrevem os resultados e as limitações de  aplicar o padrão. As consequências para software em geral se preocupam com as limitações de tempo de execução e espaço de memória. Elas também podem tratar de problemas com a linguagem de programação e a implementação. As consequências de um padrão incluem aspectos do impacto sobre a flexibilidade do sistema, extensibilidade e portabilidade da solução.

\end{enumerate}

\cite{design:patterns} classifica os padrões de projetos do ponto de vista do propósito em três categorias:
\begin{enumerate}
\item \textbf{Criação: } Padrões de criação lidam com a criação de objetos.

\item \textbf{Estrutura: } Padrões de estrutura lidam com a composição de classes e objetos.

\item \textbf{Comportamento: } Padrões de comportamento caracterizam as maneiras como as classes e objetos interagem e distribuem responsabilidade.

\end{enumerate}

Os padrões também podem ser classificados de acordo com o escopo de aplicação do padrão: Se o padrão se aplica sobre as classes ou sobre os objetos. Padrões de classes lidam com os relacionamentos entre as classes e suas subclasses. Estes relacionamentos são estabelecidos através de herança, portanto são estáticos, fixados durante a compilação. Os padrões de objetos lidam com o relacionamento entre os objetos, que podem mudar durante a execução, portanto são mais dinâmicos.

As oito características básicas na descrição dos padrões de acordo com \citeonline{design:patterns} são:
\begin{description}
\item[Nome:] Todos os padrões devem ter um único nome que os identifica.

\item[Propósito:] O propósito do padrão.

\item[Problema:] O problema que o padrão tenta resolver.

\item[Solução:] Como o padrão fornece uma solução ao problema no contexto em que ele se encaixa.

\item[Participantes e Colaboradores:] As entidades envolvidas no padrão.

\item[Consequências:] As consequências de usar o padrão. Investiga as forças relevantes no emprego do padrão.

\item[Implementação:] Como o padrão pode ser implementado. Observação: Implementações são manifestações concretas de padrões, não devem ser entendidas como o padrão em si.

\item[Estrutura Genérica:] Um diagrama UML que mostra a estrutura típica do padrão.

\end{description}

\section{Catálogo de Padrões}

Começaremos apresentando um catálogo de padrões de projetos dos dois livros, \cite{design:patterns} e \cite{DP:explained}. Durante a exposição dos padrões, veremos algumas aplicações deles. Em geral, não aplicamos os padrões de maneira isolada, mas, para resolver problemas práticos, aplicamos diversos padrões. Apesar da \textit{gang de 4}\footnote{\cite{design:patterns}} apresentar os padrões em ordem alfabética, procuraremos estudar os padrões pelos mais simples e familiares. Já apresentamos o padrão Singleton no capítulo anterior, página \pageref{p:singleton}. Além disso, procuramos deixar próximos os padrões que estão correlacionados.

\subsection{O Padrão Fachada (\textit{Facade})}
\subsubsection{Propósito}
Fornece uma interface unificada para um conjunto de interfaces num subsistema. Fachada define uma interface de alto nível que torna o subsistema mais fácil de usar.

\subsubsection{Problema}
Você precisa usar apenas um subconjunto de um sistema complexo, ou você só precisa interagir com o sistema de uma maneira específica.

\subsubsection{Solução}
A Fachada apresenta uma nova interface para o cliente de um sistema existente usar.

\subsubsection{Participantes e colaboradores}
Ela apresenta uma interface simplificada para o cliente que torna o uso do subsistema mais fácil.

\subsubsection{Consequências}
A Fachada simplifica o uso do subsistema requerido. Entretanto, como a Fachada não é completa, algumas funcionalidades podem não está disponíveis para o cliente.

\subsubsection{Implementação}
Defina uma nova classe (ou classes) que tem a interface requerida. Faça esta classe usar o sistema existente.

\subsubsection{Estrutura Genérica}
A figura \ref{fig:fachada} mostra a estrutura do sistema antes e depois de aplicar o padrão da Fachada.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.42]{fachada.png}
\caption{Estrutura Genérica do Padrão Fachada}\label{fig:fachada}
\end{center}
\end{figure}

O padrão da Fachada pode ser usado para reduzir o número de objetos com os quais um objeto cliente tem de lidar, além da simplificação da interface.

\subsection{O Padrão Adaptador (\textit{Adapter})}
\subsubsection{Propósito}
Converte a interface de uma classe em uma outra interface esperada pelos clientes. Adaptador permite que classes trabalhem juntas, o que não seria possível por incompatibilidade de interfaces.
 
\subsubsection{Problema}
Um sistema tem os dados e o comportamento corretos, mas a interface errada. Tipicamente usado quando você tem de fazer algo derivado de uma classe abstrata.

\subsubsection{Solução}
O \emph{Adaptador} fornece um embrulho (uma roupagem) com a interface desejada.

\subsubsection{Participantes e colaboradores}
O \emph{Adaptador} adapta a interface de um \emph{Adaptado} para casar com aquela do \emph{Objetivo} do Adaptador (a classe de quem ela deriva). Isto permite ao \emph{Cliente} usar o \emph{Adaptado} como se ele fosse do tipo do \emph{Objetivo}.

\subsubsection{Consequências}
O padrão Adaptador permite o uso de objetos pré-existentes em novas estruturas de classes sem ficar limitado às suas interfaces antigas.

\subsubsection{Implementação}
Contém a classe existente numa outra classe. A nova classe tem a interface requerida e chama os métodos pela classe contida.

\subsubsection{Estrutura Genérica}
A estrutura genérica do Padrão Adaptador é ilustrado na figura \ref{fig:adaptador}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{adaptador.png}
\caption{Estrutura Genérica do Padrão Adaptador}\label{fig:adaptador}
\end{center}
\end{figure}

Existem dois tipos de padrões de Adaptadores:
\begin{description}
\item[Padrão Adaptador de Objeto:] O padrão de Adaptador, geralmente, exemplificado é o Adaptador de Objeto que consiste em um objeto adaptador contendo um objeto adaptado.

\item[Padrão Adaptador de Classe:] Um outro modo de implementar o padrão Adaptador é com herança múltipla. Neste caso, temos um padrão Adaptador de Classe.
\end{description}

É comum, projetistas inexperientes não saberem diferenciar os dois padrões: Fachada e Adaptador. \cite{DP:explained} fornecem a seguinte tabela para compará-los:

\begin{table}[h]
\caption{Comparação entre os padrões Fachada e Adaptador}\label{tab:fachadaxadaptador}
\begin{center}
\begin{tabular}{lll}
 & \textbf{Fachada} & \textbf{Adaptador} \\
\hline
Há classes pré-existentes? & Sim & Sim \\
Há uma interface para a qual devemos projetar? & Não & Sim \\
Um objeto precisa ter comportamento polimórfico? & Não & Provavelmente \\
Uma interface mais simples é necessária? & Sim & Não\\
\hline %\hline
\end{tabular}
\legend{Fonte: \cite{DP:explained}}
\end{center}\end{table}

\subsubsection{Exemplo de Adaptador}
A figura \ref{fig:adaptCirc} mostra como uma classe \emph{CirculoEspc} é adaptada para uma classe \emph{Circulo}. Se o código da \emph{CirculoEspc} fosse acessível, ela poderia herdar de \emph{Circulo}, mas, se a classe faz parte de uma biblioteca externa proprietária, não será possível alterar a hierarquia de classes. Outra razão para a classe \emph{CirculoEspc} não ser derivada de \emph{Circulo} é que este tipo de projeto tem alto grau de acoplamento, herança tem alto grau de acoplamento, agregação mantêm um grau de acoplamento menor, tornando o projeto mais flexível para mudanças. 

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{adaptCirc.png}
\caption{Adaptação de CirculoEspc com Circulo}\label{fig:adaptCirc}
\end{center}
\end{figure}


\subsection{O Padrão Fabrica Abstrata (\textit{Abstract Factory})}

O padrão da Fabrica Abstrata é um dos padrões de projeto que procuram abstrair o processo de instanciação. Este tipo de padrão ajuda a tornar um sistema independente de como seus objetos são criados, compostos e representados. Ele esconde como instâncias das classes são criadas e são postas juntas.

\subsubsection{Propósito}
Fornece uma interface para a criação de famílias de objetos relacionados ou dependentes sem especificar as suas classes concretas.

\subsubsection{Problema}
Famílias de objetos relacionados precisam ser instanciadas.

\subsubsection{Solução}
Coordena a criação de famílias de objetos. Fornece uma maneira para retirar as regras de como realizar a instanciação do objeto cliente que está usando estes objetos criados.

\subsubsection{Participantes e Colaboradores}
A FabricaAbstrata define a interface de como criar cada membro da família de objetos requeridos. Tipicamente, cada família é criada usando sua própria FabricaConcreta.

\subsubsection{Consequências}
O padrão isola as regras de quais objetos usar da lógica de como usar estes objetos.

\subsubsection{Implementação}
Defina uma classe abstrata que especifica quais objetos devem ser feitos. Implemente, então, uma classe concreta para cada família.

\subsubsection{Estrutura Genérica}
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{absFact.png}
\caption{Estrutura Genérica do Padrão Fabrica Abstrata}\label{fig:absFab}
\end{center}
\end{figure}

\subsection{O Padrão Método Fabrica (\textit{Factory Method})}
\subsubsection{Propósito}
Define uma interface para a criação de um objeto, mas deixa que uma subclasse decida qual classe instanciar. Adia a instanciação para as subclasses.

\subsubsection{Problema}
Uma classe precisa instanciar uma derivação de uma outra classe, mas não sabe qual. O \emph{Factory Method} permite que uma classe derivada tome a decisão.

\subsubsection{Solução}
Uma classe derivada toma a decisão de qual classe instanciar e como.

\subsubsection{Participantes e colaboradores}
\emph{Produto} é a interface do tipo de ojeto que a \emph{Factory Method} cria. \emph{Creator} é a interface que define a \emph{Factory Method}.

\subsubsection{Consequências}
Clientes precisarão derivar a classe Creator para ter um \emph{ProdutoConcreto}.

\subsubsection{Implementação}
Use um método na classe abstrata que é abstrato. O código da classe abstrata refere-se a este método quando precisa instanciar um objeto contido , mas ainda não sabe qual objeto particular é necessário.

\subsubsection{Estrutura Genérica}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{factoryMethod.png}
\caption{Estrutura Genérica do padrão Método Fabrica.}\label{fig:factMeth}
\end{center}
\end{figure}

O padrão Método Fabrica é normalmente usado na definição de \textit{frameworks}. Isto porque frameworks existem num nível abstrato. Geralmente, eles não sabem e não deveriam se preocupar  com a instanciação de objetos específicos. Eles precisam adiar as decisões sobre objetos específicos para usuários de \textit{frameworks}.

\subsection{O Padrão Observador (\textit{Observer})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Composição (\textit{Composite})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Iterador (\textit{Iterator})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Visitante (\textit{Visitor})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Estratégia (\textit{Strategy})}
\subsubsection{Propósito}
Permite que você use regras de negócios ou algoritmos diferentes dependendo do contexto nos quais eles ocorrem.

\subsubsection{Problema}
A seleção de um algoritmo que precisa ser aplicado depende do cliente que faz a chamada ou dos dados sobre os quais ele age. Se você só tiver uma regra que não muda, você não precisa do padrão Estratégia.

\subsubsection{Solução}
Separa a seleção do algoritmo da implementação do algoritmo. Permite que a seleção seja feita baseada no contexto.

\subsubsection{Participantes e colaboradores}
\emph{Estratégia} especifica como os diferentes algoritmos são usados. \emph{EstratégiasConcretas} implementa estes diferentes algoritmos. \emph{Contexto} usa uma \emph{EstratégiaConcreta} especifica com uma referência do tipo \emph{Estratégia}. Estratégia e Contexto interagem para implementar o algoritmo escolhido. (As vezes, \emph{Estratégia} deve pedir \emph{Contexto}.) O \emph{Contexto} direciona pedidos dos seus clientes para \emph{Estratégia}.

\subsubsection{Consequências}
O padrão Estratégia define uma família de algoritmos. O uso de condicionais e switches (casos) podem ser eliminados. Você pode invocar todos os algoritmos do mesmo jeito. (Eles devem todos ter a mesma interface.) A interação entre \emph{EstratégiasConcretas} e \emph{Contexto} pode requerer a adição de métodos que obtêm o estado do \emph{Contexto}.

\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Decorador (\textit{Decorator})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Método Gabarito (\textit{Template Method})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão \textit{Singleton}}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Trava Duplamente Verificada (\textit{Lock Double Checked})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Ponte (\textit{Bridge})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Construtor (\textit{Builder})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Protótipo (\textit{Prototype})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Piscina de Objetos (\textit{Object Pool})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Cadeia de Responsabilidade (\textit{Chain of Responsability})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Comando (\textit{Command})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Peso Pena (\textit{Flyweight})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Interpretador (\textit{Interpreter})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Mediador (\textit{Mediator})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão \textit{Memento}}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão \textit{Proxy}}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\subsection{O Padrão Estado (\textit{State})}
\subsubsection{Propósito}
\subsubsection{Problema}
\subsubsection{Solução}
\subsubsection{Participantes e colaboradores}
\subsubsection{Consequências}
\subsubsection{Implementação}
\subsubsection{Estrutura Genérica}

\section{O Processo de Pensar em Padrões}

De acordo com \citeonline{design:patterns}, o processo de pensar em padrões segue os passos:
\begin{enumerate}
\item \textbf{Identifique os padrões:} Encontre os padrões no domínio do problema;
\item \textbf{Analise e aplique os padrões:} Para o conjunto de padrões a ser analisado, realize os passos a) até d):
\begin{enumerate}
\item \textbf{Ordene os padrões pelo contexto de criação:} Ordene os padrões de acordo com como eles criam contexto para cada um dos outros padrões. A ideia é a de que um padrão vai criar contexto para um outro, não que dois padrões vão criar contexto um para o outro.
\item \textbf{Selecione cada padrão e expanda o projeto:} Usando sua ordenação, selecione o próximo padrão da lista e use-o para um projeto conceitual de alto nível.
\item \textbf{Identifique padrões adicionais:} Identifique qualquer padrão adicional que surja durante a sua análise. Adicione-o ao conjunto de padrões a serem analisados.
\item \textbf{Repita:} Repita para o conjunto de padrões que ainda não foram integrados ao projeto conceitual.
\end{enumerate}
\item \textbf{Adicione detalhes:} Adicione os detalhes a medida que se tornarem necessários ao projeto. Expanda as definições das classes e dos métodos.
\end{enumerate}

\cite{DP:explained} dizem que para aplicar os padrões aos seus projetos é necessário que conheça bem o domínio do problema. Além disso, pensar em padrões nem sempre é aplicável, mas análise de comunalidade e variabilidade é geralmente mais usável. Os autores mostram como aplicar os passos no projeto de um CAD/CAM.

\chapter{Metodologias de desenvolvimento}

Existem diversas metodologias para o projeto de software OO, veremos neste capítulo uma rápida introdução a algumas destas metodologias. As chamadas metodologias de desenvolvimento visam determinar a arquitetura do software e encontrar as classes/objetos que resolvem um determinado problema. Estas metodologias são, geralmente, selecionadas pelas empresas de desenvolvimento e os programadores/projetistas devem se adaptar à metodologia da empresa. Os gerentes de desenvolvimento que selecionam as metodologias têm diversos critérios para realizar a escolha: experiência da equipe, disponibilidade de ferramentas dentro da empresa, requerimentos dos clientes finais, ... Algumas vezes, a escolha se faz por motivos não totalmente objetivos. Não vamos aqui discutir os méritos e deméritos das metodologias para não entrar em batalhas, muitas vezes infindáveis e infrutíferas.

\cite{uml:j2ee} diz que um processo de desenvolvimento de software fornece orientação sobre como desenvolver software com sucesso. Essa orientação pode abranger todo o espectro de atividades associadas ao desenvolvimento do software. O processo pode se manifestar sob a forma de abordagens comprovadas, melhores práticas, diretrizes, técnicas, sequenciamento de atividades, etc.

Seja formal ou informal, o processo de desenvolvimento de software utilizado tem impacto profundo no sucesso de um projeto de software. Uma abordagem de tentativa e erro pode funcionar bem para um pequeno projeto, mas pode levar ao caos em um grande projeto e impactar o cronograma geral. Da mesma forma, um processo de desenvolvimento de software burocrático pode levar à frustração e ao atolamento até mesmo a melhor das equipes.

\cite{DP:explained} diz que frequentemente os projetistas novatos em OO são aconselhados a olhar para o domínio do problema e ``identificar os substantivos presentes'' e criar objetos representando-os e encontrar os verbos relacionando estes substantivos (isto é, as ações deles) e implementá-los através de métodos dos objetos. Este processo focado em substantivos (nomes das coisas) e verbos leva, tipicamente a hierarquias de classes maiores do que as desejáveis. Eles recomendam a análise de coisas em comum, comunalidade, e coisas que variam, variabilidade, como a principal ferramenta para a criação de objetos. Os conceitos de comunalidade e variabilidade foram apresentados por Couplien\footnote{Couplien, J., \textit{Multi-Paradigm Design for C++}, Boston: Addison-Wesley, 1998, pp. 60, 64.}.

A figura \ref{fig:cvaPersp} mostra as relações entre a análise de comunalidades e variabilidades, perspectivas e classes abstratas. Ao olhar o que os objetos devem fazer (perspectiva conceitual), determinamos como chamá-los (perspectiva de especificação) e obtemos as classes abstratas e seus métodos. Ao implementar estas classes, garante-se que a API fornece informação suficiente para uma implementação adequada e um bom desacoplamento.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{cva_persp.png}
\caption{Relação entre Análise de Comunalidade e de Variabilidade, Perspectivas e Classes abstratas} \label{fig:cvaPersp}
\legend{Fonte: \cite{DP:explained}}
\end{center}
\end{figure}

A tabela \ref{tab:concDS} apresenta alguns conceitos e termos usados em desenvolvimento de Software.

\begin{longtable}[l]{p{4.6cm}p{11.1cm}}
\caption[Conceitos DS]{Conceitos e Termos Desenvolvimento de Software}
\label{tab:concDS}\\

\multicolumn{1}{c}{\textbf{Termo}} & \multicolumn{1}{c}{\textbf{Descrição}} \\
\midrule
\endfirsthead

\multicolumn{2}{c}{{\bfseries \tablename\ \thetable{} -- continuação da página anterior}} \\
\multicolumn{1}{c}{\textbf{Termo}} & \multicolumn{1}{c}{\textbf{Descrição}} \\
\midrule
\endhead

\multicolumn{2}{r}{{Continua na próxima página}} \\% \hline
\endfoot

\hline %\hline
 & \legend{Fonte: \cite{uml:j2ee}} \\% \hline

\endlastfoot

Caso de Uso & ...\\

Desenvolvimento em Cascata & Processo de desenvolvimento que segue estritamente as etapas: Levantamento de requisitos, Análise e Projeto do SW, Codificação, Teste e Manutenção.\\

Estória de Usuário & ...\\

Framework & Quadro de trabalho, em tradução ao pé da letra. Um framework é uma coleção de programas que facilitam o desenvolvimento de uma aplicação. De acordo com \cite{uml:j2ee}, existem dois tipos de framewoks: um baseado em biblioteca e outro que fornece uma base a ser extendida pelo programador.\\

Metodologia de Desenvolvimento de Software & Processo de desenvolvimento de software baseado em práticas bem definidas.\\

Metodologia Ágil & Processo de desenvolvimento de Software que procura reduzir o ciclo de entrega de incremental do software, privilegiando a interação com o cliente e a programação.\\

Processo de Desenvolvimento & Técnicas e procedimentos práticos para o desenvolvimento de Software.\\

RUP & Processo Unificado da Rational - \textit{Rational Unified Process}.\\

Scrum & Uma metodologia ágil.\\

XP & eXtreme Programming, uma metodologia ágil.\\

\end{longtable}

A exposição das metodologias começa com o processo unificado que de certa maneira representou o fim da guerra das metodologias, não que ela seja a metodologia vencedora. Apenas, o processo unificado ofuscou as outras e não temos mais uma disputa tão pronunciada de metodologias deste que ela foi publicada, ela é o resultado da unificação de metologias pelos 4 amigos: Philippe Kruchten,  Ivar Jacobson, Jim Rumbaugh e Grady Booch. Conforme veremos, o principal representante da metodologia é chamada de RUP, Rational Unified Process, e varições dela são usadas por muitas empresas. Inicialmente, a metodologia era muito centrada na criação de documentos e o desenvolvimento do software só ocorria depois da escrita deles. Alguns desenvolvedores criaram metodologias chamadas de ágeis que pretendem reduzir a burocracia antes da programação. 15 destes desenvolvedores lançaram o Manifesto pelo Desenvolvimento de Software Ágil, (\citeonline{agile:manifesto}), eles enunciaram 12 princípios básicos:

\begin{enumerate}
\item 
Nossa maior prioridade é satisfazer o cliente através da entrega antecipada e contínua de software valioso.

\item
Mudanças de requisitos são bem-vindas, mesmo nas etapas finais do desenvolvimento. Processos ágeis aproveitam mudanças para oferecer vantagem competitiva ao cliente.

\item
Entregar software de trabalho com frequência, de algumas semanas a alguns meses, com uma preferência para a escala de tempo mais curta.

\item
Clientes e desenvolvedores devem trabalhar juntos diariamente durante todo o projeto.

\item
Construa projetos em torno de indivíduos motivados. Dê a eles o ambiente e o suporte de que precisam e confie neles para fazer o trabalho.

\item
O método mais eficiente e eficaz de transmitir informações para e dentro de uma equipe de desenvolvimento é conversa cara a cara.

\item
O software de trabalho é a principal medida de progresso.

\item
Processos ágeis promovem o desenvolvimento em ritmo sustentável. Os patrocinadores, desenvolvedores e usuários devem ser capazes de manter um ritmo constante indefinidamente.

\item
Atenção contínua à excelência técnica e um bom projeto aumentam a agilidade.

\item
Simplicidade é essencial.

\item
As melhores arquiteturas, requisitos e projetos emergem de equipes auto-organizadas.

\item
Em intervalos regulares, a equipe reflete sobre como se tornar mais eficaz, em seguida, se sintoniza e ajusta seu comportamento de acordo.
\end{enumerate}

Veremos uma rápida introdução à metodologia Scrum na seção \ref{s:scrum} para exemplificar as metodologias ágeis. E concluiremos o capítulo citando outras metologias ágeis.

\section{Processo Unificado}

...texto sobre o processo unificado, RUP, e variações...
\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.6]{File_Development-iterative-RUP-wiki.png}
\caption{Diagrama das etapas do RUP} \label{fig:rup}
\legend{Fonte: \citeonline{wiki:RUP}}
\end{center}
\end{figure}
A figura \ref{fig:rup} mostra um diagrama com as etapas e fases do processo de desenvolvimento RUP.

\section{Breve Introdução ao Scrum} \label{s:scrum}

\subsection{O Que É Scrum?}
Scrum é um framework projetado para ajudar pequenas equipes unidas a desenvolver produtos complexos. Resultado do trabalho de um punhado de engenheiros de software trabalhando juntos no final do século XX, scrum ganhou força no setor tecnológico, mas não é necessariamente técnico e pode ser facilmente adaptado para outras indústrias. Os autores \citeonline{scrum:brief} dizem que você pode adaptá-lo para construir uma ratoeira melhor, ou para administrar a divisão de \textit{marketing} de uma companhia de cachorrinhos de estimação, ou até para escrever um livro, como eles fizeram.

Uma equipe scrum consiste, tipicamente, de cinco a nove pessoas que trabalham juntas em curtos intervalos de intensa atividade chamadas de arrancadas (\emph{sprints}), com bastante tempo embutido para revisão e reflexão. Um dos mantras de scrum é ``inspecionar e adaptar'' e equipes scrum são caracterizadas por um foco intenso  na melhoria contínua do processo delas e do produto. Nesta seção veremos uma introdução muito rápida da terminologia do scrum: os vários papéis, artefatos e eventos que ocorrem num ciclo de arrancada (\emph{sprint cycle}).

\subsection{Papéis}
O Scrum conhece três papéis distintos para os membros da equipe:
\begin{description}
\item[Proprietário do Produto] O proprietário do produto (\emph{product owner}) é responsável pela maximização do retorno que o negócio traz ao investimento (ROI - Return-Of-Investment). Ele é o único que controla a ordem, a prioridade, da lista de pendências (\textit{backlog itens}) da equipe. Ele garante que a equipe entende totalmente os requisitos. Ele registra os requisitos na forma de estórias de usuário (\emph{user stories}), por exemplo: ``Como um <papel - tipo de usuário>, quero <uma característica>, de modo que possa <fazer algo>'' e coloca-as na lista de pendências. Cada uma destas estórias de usuário, quando completada, aumentará o valor do produto.

\item[Mestre Scrum] O Mestre Scrum age como um \textit{coach} (treinador), guiando a equipe para níveis mais altos de coesão, auto-organização e desempenho. Enquanto a equipe entrega o produto, o Mestre Scrum entrega uma equipe de alto desempenho e auto-organizada. O Mestre Scrum ajuda a equipe a aprender e aplicar scrum e outras práticas ágeis relacionadas. O mestre scrum está sempre disponível para ajudar a equipe na remoção de obstáculos que estejam bloqueando a execução do trabalho. O mestre scrum não é o chefe, ele é um membro da equipe que se destaca pelo seu conhecimento e suas responsabilidades.

\item[Membro de Equipe] Equipes scrum de alto desempenho são altamente colaborativas, elas também são auto-organizadas. Os membros da equipe têm total autoridade sobre como o trabalho é realizado. A equipe decide por si quais são as ferramentas a serem usadas e quais membros irão trabalhar em quais tarefas. Se o negócio precisa de estimativas de cronograma, são os membros da equipe que criam as estimativas. Uma equipe scrum deve possuir todas as capacitações necessárias para criar um produto entregável. Ocasionalmente, pode ser que um membro tenha de trabalhar fora da sua especialidade para que um item da lista de pendências (uma estória de usuário) saia do estado ``progredindo'' para ``feito''. Esta é uma mudança de mentalidade do ``faço meu serviço'' para ``faço o serviço''. 

\end{description}

O proprietário do produto:
\begin{itemize}
\item detém a visão do produto;
\item representa os interesses do negócio;
\item representa os clientes (\textit{stockholders});
\item é dono da lista de pendências do produto (\textit{product backlog});
\item ordena, prioriza, os itens da lista de pendências do produto;
\item cria critérios de aceitação para os itens da lista de pendências do produto; e
\item está disponível para responder às dúvidas dos outros membros da equipe.
\end{itemize}

O papel do Mestre Scrum é ser:
\begin{itemize}
\item especialista e orientador de scrum;
\item treinador;
\item quebrador de barreiras; e
\item facilitador.
\end{itemize}

O papel de Membro da Equipe:
\begin{itemize}
\item é ser responsável por completar as estórias do usuário para incrementar o valor do produto;
\item se auto-organizar para conseguir que todo o trabalho necessário seja feito;
\item criar suas próprias estimativas de cronogramas;
\item decidir ``como fazer o trabalho''; e
\item fugir do pensamento ``não é meu serviço''.
\end{itemize}

\subsection{Artefatos do Scrum}
\subsubsection{A Lista de Pendências do Produto (\emph{Product Backlog})}
A lista de pendências do produto é uma lista acumulativa de itens entregáveis desejados para o produto. Isto inclui características, consertos de erros (\emph{bug fixes}), alterações na documentação e qualquer outra coisa que seja significativa e valiosa para produzir. Embora pendência seja um termo correto para um item da lista, as equipes de scrum preferem usar o termo estória de usuário para reforçar a noção de que construímos produtos para satisfazer as necessidades dos usuários.

Cada item da lista deve incluir as seguintes informações:
\begin{itemize}
\item Quais usuários vão se beneficiar da estória;
\item Uma rápida descrição da funcionalidade desejada (o que precisa ser construído);
\item A razão para a estória ser preciosa (por que precisamos realizá-la);
\item Uma estimativa de quanto trabalho será necessário para realizar a estória; e
\item Critérios de aceitação que ajudarão a saber se a implementação está correta.
\end{itemize}

\subsubsection{A Lista de Pendências da Arrancada (\emph{Sprint Backlog})}
A lista de pendências da arrancada é a lista de coisas a fazer na arrancada, período fixo de tempo de trabalho. Diferente da lista de pendências do produto, ela tem tempo de vida finito: a duração da arrancada. Ela inclui todas as estórias e tarefas associadas que a equipe se compromete a realizar nesta arrancada. Estórias são entregas e podem ser pensadas como unidades de valor. Tarefas são coisas que precisam ser feitas, para entregar as estórias, logo, tarefas podem ser vistas como unidades de trabalho. Uma estória é algo que uma equipe entrega; Uma tarefa é um pedaço de trabalho que alguém faz. Cada estória normalmente requer muitas tarefas.

\subsubsection{Gráficos de Queimada}
Um gráfico de queimada (\emph{burn chart}) nos mostra a relação entre o tempo e o escopo. O tempo está no eixo horizontal X e o escopo está no eixo vertical Y. Um gráfico de queimada nos mostra quanto de escopo uma equipe conseguiu realizar num período de tempo. Cada vez que algo é completado, a linha no gráfico se move para cima. Um gráfico de queimada nos mostra o que falta fazer. Em geral, esperamos que o trabalho restante diminua com o tempo à medida que a equipe termina tarefas. Às vezes, o trabalho restante muda de repente, quando escopo é adicionado ou retirado. Estes eventos aparecem como linhas verticais no gráfico de queimada.

\subsubsection{Quadro de Tarefas}
Para todos os integrantes da equipe Scrum acompanharem o andamento do trabalho, um quadro de tarefas é colocado numa sala usada por todos os integrantes. Isto evita que alguma parte importante do trabalho seja esquecida.

O quadro de tarefas mais simples tem três colunas: A fazer, Fazendo e Terminada. As tarefas são deslocadas através das colunas do quadro, fornecendo visibilidade para quais tarefas foram terminadas, quais estão sendo feitas e quais ainda não começaram. Esta visibilidade ajuda a equipe a ver a situação atual e se adaptar conforme a necessidade. O quadro também ajuda os clientes a verem o progresso que a equipe está fazendo. Com a ideia de usar os artefatos mais simples, o quadro é uma superfície onde podemos colar \textit{post-it}s com as tarefas escritas neles. Estes post-its são colocados nas 3 colunas conforme a evolução das atividades.

\begin{center}
\parbox{16cm}{
\textbf{Definição de Terminada}\\
\textit{Terminada} é uma palavra fantástica, quando a equipe consegue que uma estória de usuário seja terminada, é hora de festejar. Mas, às vezes, há uma certa confusão sobre o que exatamente \emph{terminada} significa. Um programador pode dizer que alguma coisa está terminada quando o código está escrito. Um testador pode pensar que terminada significa que todos os testes passaram. O pessoal de operações pode pensar que terminada significa que os programas foram carregados nos servidores de produção. Uma pessoa do comercial pode pensar que terminada significa que podemos vender aos clientes e que está pronta para uso. Esta confusão sobre o que \emph{terminada} significa pode causar problemas, quando, por exemplo, o vendedor pergunta por que a equipe ainda está trabalhando numa estória que o programador disse estar terminada há duas semanas.

Para evitar confusão, as boas equipes de scrum devem ter sua definição de como a palavra \emph{terminado} se aplica a uma estória de usuário. Elas decidem juntas que coisas precisam ser concluídas antes da equipe declarar que uma estória foi terminada. A definição da equipe pode incluir coisas como: código escrito, código revisto, aprovação nos testes unitários, documentação escrita, assinatura do proprietário do produto, ... Esta é a lista de coisas, que a equipe concorda em fazer sempre antes de declarar que uma estória está terminada, é a definição da equipe do que significada estória \emph{terminada}. A equipe deve imprimir a definição de terminada como uma lista a ser checada próxima do quadro de tarefas. Quando a equipe acha que uma \emph{estória} está \emph{terminada}, verifica-se que todos os itens da lista foram concluídos.
}

\end{center}

\subsection{O Ciclo da Arrancada (\textit{Sprint Cycle})}

O ciclo da arrancada consiste de várias reuniões, chamadas de cerimônias, para satisfazer as pessoas que não gostam da palavra reunião:
\begin{itemize}
\item planejamento da arrancada;
\item scrum diário;
\item hora da estória;
\item revisão da arrancada e
\item retrospectiva.
\end{itemize}

\noindent \textbf{É uma questão de ritmo}

O ciclo da arrancada é o ritmo fundamental do processo scrum. Como quer que você chame seu período de desenvolvimento: Uma arrancada (\emph{sprint}), um ciclo, ou uma iteração. Você está sempre falando da mesma coisa: Um \emph{período fixo} de tempo no qual você mastiga pedaços do seu projeto e termina-os antes de morder mais. No final da arrancada, você mostrará algum software funcionando.

Quanto mais frequente forem as entregas da equipe de incrementos do produto, maior a liberdade do negócio para decidir quando e o que entregar. Observe que existem duas decisões separadas a serem tomadas aqui:

\begin{description}
\item[O produto tem potencial para ser comercializado?] Isto é, a qualidade é boa o suficiente para que seja comercializado? Todas as estórias atuais terminaram? Esta é uma decisão da equipe.
\item[Tem sentido comercializar o que temos no momento?] Existe valor agregado suficiente para levar o produto atual para o mercado? Esta é uma decisão de negócios.
\end{description}

Adicionalmente, quanto maior a frequência com que a equipe produz incrementos entregáveis do produto, maior a frequência de retornos para a equipe, o que alimenta o importante ciclo de inspecionar-e-adaptar. Quanto mais curto o ciclo da arrancada, com maior frequência a equipe produz valor para o negócio.

Por volta do inicío dos anos 2010, as equipes de scrum trabalhavam com arrancadas de duas semanas e muitas equipes começavam a trabalhar com arrancadas de uma semana. Muitos dos escritos originais de scrum assumiam arrancadas com um duração de um mês e naquela época, isto parecia curto.

A tabela da figura \ref{fig:sprint} esboça o mapeamento das cerimônias que você deve agendar para uma arrancada de uma semana. A duração das cerimônias são uma sugestão inicial, as equipes devem adaptar para suas próprias características.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{sprint_planning.png}
\caption{Agenda diária para um Sprint de uma semana} \label{fig:sprint}
%\legend{Fonte: \citeonline{wiki:RUP}}
\end{center}
\end{figure}

\subsubsection{Cerimônia de Planejamento da Arrancada}

A cerimônia de planejamento da arrancada marca o início da arrancada. O objetivo da primeira parte da cerimônia é o comprometimento da equipe para a entrega dos produtos da arrancada. Na segunda parte da cerimômia, a equipe identifica as tarefas que devem ser completadas para as entregas baseadas nas estórias de usuários. Recomenda-se uma cerimônia de planejamento de uma a duas horaas de duração por semana de desenvolvimento.

\noindent \textbf{\small Parte Um: O que faremos?}

A meta da primeira parte da cerimônia de planejamento da arrancada é ter um conjunto de estórias que a totalidade da equipe se compromete a entregar no fim da arrancada. O \emph{proprietário do produto} lidera esta parte da cerimônia.

Uma a uma, na ordem decrescente de prioridade, o proprietário do produto apresenta as estórias que ele gostaria que a equipe completasse durante a arrancada. A medida que cada estória for apresentada, os membros da equipe a discutem com o proprietário do produto e reveem critérios de aceitação para ter certeza que eles têm um entendimento único do que se espera. Então, os membros da equipe decidem se eles podem se comprometer na entrega da estória no final da arrancada. Este processo se repete para cada estória até que a equipe sinta que não pode mais se comprometer com mais trabalho. Observe a separação de autoridade, o proprietário do produto decide quais são as estórias a serem consideradas, mas são os membros da equipe que realizam o trabalho que decidem quanto trabalho eles podem fazer.

\noindent \textbf{\small Parte Dois: Como faremos?}

Na fase dois da cerimônia de planejamento da arrancada, a equipe começa a decompor as estórias selecionadas em tarefas. Lembre-se que as estórias são os produtos entregáveis: Coisas que os contratantes, usuários e clientes querem. Para entregar uma estória, os membros da equipe terão de terminar as tarefas. Tarefas são coisas como: Obtenha mais entradas dos usuários; projete uma nova tela; adicione colunas a um banco de dados; escreva texto de ajuda (help); Faça a tradução do menu para as localidades alvo; execute os scripts de entrega.

O proprietário do produto deve estar disponível pelo menos durante metade da cerimônia para responder às questões. A equipe pode também precisar ajustar a lista de estórias para a qual ela está se compromentendo, já que na fase de identificação das tarefas, os membros da equipe podem percerber que eles se comprometeram com um excesso de estórias ou com um número insuficiente.

O resultado da cerimônia de planejamento da arrancada é o \textit{sprint backlog} (a lista de pendências da arrancada), a lista de todas as estórias que a equipe se compromete a entregar, com as tarefas associadas. O proprietário do produto concorda em não pedir estórias adicionais durante a arrancada, a menos que a equipe especificamente solicite mais. O proprietário do produto também concorda em está disponível para responder questões sobre as estórias, negociar o escopo delas e fornecer orientações sobre o produto até as estórias serem aceitáveis e forem consideradas terminadas.

\subsubsection{Scrum Diário}

A cerimônia de scrum diário, chamada às vezes de \textit{stand-up meeting}, é:
\begin{description}
\item[Diária:] A maioria das equipes escolhe fazer esta cerimônia no início do dia de trabalho. Você pode adaptá-la para as preferências da sua equipe.
\item[Breve:] Um ponto desta cerimônia é desencorajar as discursões e os desvios que tornam as reuniões um inferno. O scrum diário deve sempre durar no máximo 15 minutos.
\item[Direta:] Cada participante rapidamente compartilha:
\begin{itemize}
\item Quais tarefas completei desde o último scrum diário;
\item Quais tarefas espero completar até o próximo scrum diário; e
\item Quais obstáculos estão me retardando.
\end{itemize}
\end{description}

O objetivo desta cerimônia é inspecionar e adaptar o trabalho dos membros da equipe para que as estórias comprometidas pela equipe sejam completadas com sucesso. A inspeção acontece na cerimônia, a adaptação pode ser feita depois dela. Isto significa que a equipe não precisa resolver os problemas na cerimônia, apenas trazer à torna as questões e decidir quais membros da equipe vão se ocupar delas é, normalmente, o suficiente. Lembre-se, a cerimônia é breve.

\subsubsection{Hora de Estória}

Nesta cerimônia, você discutirá e melhorará as estórias na lista de pendências do produto, \emph{product backlog}, que contém todas as estórias para as futuras arrancadas. Observe que não são as estórias da arrancada atual, estas estão nas pendências da arrancada, \emph{sprint backlog}. Recomenda-se que a cerimônia dure uma hora por semana, toda semana, independente da duração da sua arrancada. Nesta cerimônia, a equipe trabalha com o proprietário do produto para:

\noindent \textbf{\small Definir e Redefinir Critérios de Aceitação}

Cada estória de usuário na lista de pendências do produto deve incluir uma lista de critérios de aceitação. Estas são condições testáveis para aprovado/reprovado que nos ajudam a saber quando uma estória está implementada como se pretendia. Algumas pessoas pensam nelas como exemplos de aceitação: Os exemplos que a equipe vai usar para mostrar que uma estória está terminada.

\noindent \textbf{\small Tamanho da Estória}

Durante a cerimônia do tempo de estória, a equipe vai atribuir (ou estimar) um tamanho para as estórias que ainda não tiverem seus tamanhos estimados. O tamanho é uma adivinhação da equipe sobre a quantidade de trabalho que uma estória necessita para ser completada.

\noindent \textbf{\small Divisão da estória}

Estórias no topo da lista de pendências do produto precisam ser pequenas. Estórias pequenas são fáceis para todos entenderem e fáceis para a equipe completar em um curto espaço de tempo. Estórias mais no fundo da lista de pendências do produto podem ser maiores e menos bem definidas. Isto implica em que temos de quebrar estórias maiores em estórias menores a medida que as estórias sobem na lista. Enquanto o proprietário do produto pode fazer esta quebra por conta própria, o tempo de estória é a oportunidade dele ter ajuda de todo a equipe para esta atividade.

A cerimônia do tempo de estória não é uma \emph{cerimônia oficial} do scrum. Mas as equipes de scrum de alto desempenho costumam usá-la.

\subsubsection{Revisão da Arrancada}

Este é o final público da arrancada, convide todos os interessados (\textit{stockholders}) para esta cerimônia. É a oportunidade da equipe mostrar seus sucessos, as estórias que cumpriram a definição de terminada da equipe. Esta também é uma oportunidade para os interessados verem como o produto melhorou com a arrancada.

Se existirem estórias que a equipe se comprometeu a terminar, mas não conseguiu, este é o momento para compartilhar esta informação com os interessados. O evento principal desta cerimônia é, obviamente, mostrar as estórias terminadas. Sem dúvidas, os interessados darão um retorno e idéias que o proprietário do produto e a equipe usarão na fase de inspeção-e-adaptação do produto.

Esta cerimônia não é uma reunião para tomar decisões. Não é onde decidimos se uma estória está terminada, isto é feito antes. Não é quando decidimos sobre o que faremos em seguida, na próxima arrancada, isto é feito na cerimônia de planejamento da arrancada.
Quão longa deve ser a cerimônia de revisão da arrancada? Recomenda-se que seja agendada por meia hora a uma hora por semana de desenvolmento.

\subsubsection{Retrospectiva}

Enquanto a revisão da arrancada é o término público da arrancada, a equipe ainda tem mais uma cerimônia: A retrospectiva. Scrum foi projetado para ajudar as equipes a inspecionar e adaptar continuamente, resultando em desempenho cada vez melhor e felicidade. A retrospectiva, que tem lugar no final de cada arrancada, é um tempo dedicado para a equipe se focar no que foi aprendido durante a arrancada e como este aprendizado pode ser usao para melhorar a equipe. Recomenda-se uma a duas horas por semana de desenvolvimento.

Diferente da análise \textit{post mortem}, o objetivo de uma retrospectiva nunca é gerar uma longa lista de lavagem das coisas que funcionaram e das que deram errado, mas identificar uma ou duas mudanças de estratégia para a próxima arrancada. Ela serve para melhorar o processo.

\subsubsection{Término Anormal da Arrancada}

Em scrum, o acordo básico entre a gerência e a equipe é que a gerência não vai mudar os requisitos durante uma arrancada. Ainda assim, às vezes, algo acontece que invalida tudo no plano de uma arrancada -- o negócio é vendido, uma tecnologia disruptiva entra no mercado, um competidor faz um movimento. A decisão de terminar uma arrancada mais cedo é fundamentalmente uma decisão de negócios, logo o proprietário do produto é quem pede o término anormal de uma arrancada.

Se o proprietário do produto decide terminar precipitadamente uma arrancada, a equipe deve voltar ao estado anterior à arrancada para não trabalhar com modificações incompletas. Realizar uma cerimônia de retrospectiva é particularmente importante após um término anormal para ajudar a equipe a aprender com a experiência.

\subsubsection{Inspecione e Adapte}

Então, por que desenvolvemos o trabalho em ciclos curtos? Para aprender. Experiência é o melhor professor e o ciclo de scrum é projetado para lhe fornecer várias oportunidades de receber retornos -- dos clientes, da equipe, do mercado -- e aprender com eles.
O que você aprende ao trabalhar num ciclo, prepara você para o planejamento do próximo ciclo. Em scrum, chamamos isto de \emph{inpecionar-e-adaptar}. Você pode chamá-lo de \emph{melhoria contínua}. De qualquer modo, é uma coisa boa.

\section{Outras metodologias ágeis}
\subsection{\emph{Full Test Driven Development} - FTDD}
\subsection{\emph{EXtreme Programmig} - XP}
\subsection{\emph{Agile Modeling Driven Development} - AMDD}

\chapter{Codificação em Java}

Veremos neste capítulo alguns exemplos de código Java para os conceitos vistos até o presente e mais alguns novos bastante usados.

\section{Exemplo de MVC - \emph{Model-View-Controller}}

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.7]{MVC.png} 
\caption{Arquitetura \emph{Model-View-Controller}} \label{fig:mvc}
\end{center}
\legend{Fonte: \citeonline{uml:j2ee}}
\end{figure}

O exemplo a seguir vem de \citeonline{just:java2}. Nele mostramos um exemplo simples da arquitetura MVC usada para aplicações com GUI, interface usuário gráfica. A figura \ref{fig:mvc} mostra os princípios desta arquitetura. O \emph{modelo} na arquitetura encapsula a lógica de negócio da solução do problema resolvido pela aplicação. A \emph{visão} contém o código que exibe o estado do modelo para o usuário e a interface para o usuário interagir com a aplicação. O \emph{controlador} recebe os eventos de entrada do usuário que vêm pela interface com o usuário, a \emph{visão}. Estes eventos podem modificar o que está sendo exibido ou como está sendo exibido pela \emph{visão}. Estes eventos do usuário também podem provocar mudanças no estado do \emph{modelo}. Mudanças no estado do \emph{modelo} podem gerar notificações de alterações para a \emph{visão}.

O programa é simplesmente um relógio em Java. A figura \ref{fig:clock} mostra o diagrama de classes da aplicação. Compare com o diagrama de dependência da figura \ref{fig:clsDep}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{clock.png} 
\caption{Diagrama de classes do relógio digital.} \label{fig:clock}
\end{center}
\end{figure}

\begin{verbatim}
public class TimeStamp {
    private int hrs;
    private int mins;
    private int secs;
    
    public void fillTimes() {
        java.util.Calendar now;
        now = java.util.Calendar.getInstance();
        hrs = now.get(java.util.Calendar.HOUR_OF_DAY);
        mins = now.get(java.util.Calendar.MINUTE);
        secs = now.get(java.util.Calendar.SECOND);
    }
    public getHrs() { return hrs; }
    public getMins() { return mins; }
    public getSecs() { return secs; }
}
\end{verbatim}

A classe \emph{TimeStamp} tem como atributos a hora, os minutos e os segundos e um método que atualiza os valores dos atributos com a ajuda da classe \emph{java.util.Calendar} do sistema. A \emph{TimeStamp} modela a ``lógica de negócio'' de um relógio. A classe \emph{Calendar} do pacote \emph{java.util} é uma classe que vem na biblioteca padrão distribuída com o JDK, kit de desenvolvimento do Java. Observe que os atributos estão ocultos dos usuários da classe \emph{TimeStamp}, os valores deles podem ser obtidos através dos métodos \textit{getters} dos atributos. Se mais tarde, for decidido que se deseja mais alterar estes atributos, pode se reprogramar os métodos \textit{getters} de acordo com as mudanças e os usuários da classe não precisam saber que os atributos foram modificados. Dizemos que isolamos os usuários da classe \emph{TimeStamp} das modificações nos atributos ocultos. Precisamos, entretanto, manter o contrato de que os métodos \emph{getHrs()}, \emph{getMins()} e \emph{getSecs()} continuam a fornecer as horas, os minutos e os segundos.

\begin{verbatim}
public class ClockView extends javax.swing.JFrame {
    private javax.swing.JLabel tLabel = new javax.swing.JLabel();
    
    public ClockView() {
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setSize(95,45);
        getContentPane().add(tLabel);
        refreshTimeDisplay();
    }
    
    protected String getDigitAsString(int i) {
        String str = Integer.toString(i);
        if (i<10) str = "0" + str;
        return str;
    }
    
    public void refreshTimeDisplay() {
        TimeStamp ts = new TimeStamp();
        ts.fillTimes();
        String display = getDigitAsString(ts.getHrs()) + ":"
                     + getDigitAsString(ts.getMins()) + ":"
                     + getDigitAsString(ts.getSecs());
        tLabel.setText("  " + display);
        tLabel.repaint();
    }
}
\end{verbatim}

% os códigos podem ir para minipáginas flutuantes/ou presas
A classe \emph{ClockView} é a nossa classe de visualização. Ela herda da classe \emph{javax.swing.JFrame}. O pacote \emph{javax.swing} é parte da nova biblioteca do Java para a criação de interfaces gráficas para usuários para aplicações de \textit{desktop}. Ao herdar de \emph{JFrame}, um objeto \emph{ClockView} serve de base para a janela onde estará o relógio. O único elemento gráfico que é adicionado ao painel da janela é um \emph{JLabel}. Um objeto \emph{JLabel} permite a exibição de um texto. Para transformar a informação do objeto TimeStamp em texto a ser exibido (variável \emph{display}), a classe ClockView tem o método auxiliar \emph{getDigitAsString(int)} que converte um inteiro em texto. Observe que não foram tomados cuidados para garantir que o inteiro só tem 2 dígitos. Como sabemos que os dados vem da TimeStamp corretamente, não é necessário fazer este tipo de checagem.

\begin{verbatim}
public class Clock {
    public static void main(String[] argv) {
        new Clock().go();
    }
    public void go() {
        ClockView cv = new ClockView();
        cv.setVisible(true);
        try {
            for (;;) {
                cv.refreshTimeDisplay();
                Thread.sleep(500);
            }
        } catch (Exception e) {
            System.out.println("Erro: " + e);
        }
    }
}
\end{verbatim}

A classe \emph{Clock} é a controladora da aplicação. Como o relógio digital é muito simples, tudo que ela tem é o método \emph{main()} que repete para sempre (\emph{loop} infinito) a atualização da tela do relógio e espera por meio segundo (dormindo). A espera é importante para liberar o processador do computador para outras aplicações. A razão de esperar por meio segundo e não por um segundo é que o erro de exibição no caso da espera de um segundo pode ser de até um segundo. No pior caso o programa leu as horas com o objeto TimeStamp justo quando ia mudar o segundo e mostra o valor anterior, só após o tempo de espera de 1s é que a tela vai ser atualizada. Com meio segundo de espera, o erro máximo é de 0,5s.

\section{Programação J2EE}


% ---
% Finaliza a parte no bookmark do PDF, para que se inicie o bookmark na raiz
% ---
\bookmarksetup{startatroot}% 
% ---

% ---
% Conclusão
% ---
%\section*{Considerações finais}
%\addcontentsline{toc}{section}{Considerações finais}
%
%Texto qualquer.
%
%\begin{citacao}
%Mais texto genérico.
%\end{citacao}
%
%Texto.

% ----------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ----------------------------------------------------------
\postextual

% ---
% Título e resumo em língua estrangeira
% ---

% \twocolumn[    		% INICIO DE ARTIGO EM DUAS COLUNAS

% titulo em inglês
%\titulo{Canonical academic article model with \abnTeX}
%\emptythanks
%\maketitle
%
%% resumo em português
%\renewcommand{\resumoname}{Abstract}
%\begin{resumoumacoluna}
% \begin{otherlanguage*}{english}
%   According to ABNT NBR 6022:2003, an abstract in foreign language is a back
%   matter mandatory element.
%
%   \vspace{\onelineskip}
% 
%   \noindent
%   \textbf{Keywords}: latex. abntex.
% \end{otherlanguage*}  
%\end{resumoumacoluna}

% ]  				% FIM DE ARTIGO EM DUAS COLUNAS
% ---

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{oo_refs}
\

\end{document}
